{
  "comments": [
    {
      "key": {
        "uuid": "3f2c6c7a_480a1f41",
        "filename": "src/main/java/com/google/gwtorm/jdbc/JdbcAccess.java",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-06-17T16:59:15Z",
      "side": 1,
      "message": "In the transaction model implied by Access (and required by googlesource.com), there can only be one transaction open at a time, and any mutation operations can only operate on entities sharing the same root key (the last non-null key returned by iterated getParentKey() calls).\n\nThat is not strictly required for this implementation, but it would be nice to have sanity checks, so it stops being so easy to write code that passes on a SQL dialect but fails on googlesource.com.",
      "range": {
        "startLine": 42,
        "startChar": 31,
        "endLine": 42,
        "endChar": 37
      },
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4485179_e3e7524c",
        "filename": "src/main/java/com/google/gwtorm/jdbc/JdbcAccess.java",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2014-06-17T18:22:19Z",
      "side": 1,
      "message": "Can you be more precise on what do you mean by sanitiy checks? Would\n\n  Preconditions.checkNotNull(key);\n\nbe sufficient?",
      "parentUuid": "3f2c6c7a_480a1f41",
      "range": {
        "startLine": 42,
        "startChar": 31,
        "endLine": 42,
        "endChar": 37
      },
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0424bda2_b623e8c6",
        "filename": "src/main/java/com/google/gwtorm/jdbc/JdbcAccess.java",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1011323
      },
      "writtenOn": "2014-06-18T06:49:59Z",
      "side": 1,
      "message": "OK, now i understand what you mean: to save here key as  entityGroupKey and the type, and check in every Access method (by generating new byte code) that mutated entity belongs to the entityGroup (through getParentKey() call through the whole hierarchie until getParentKey() returns null).\n\nBut then again, this is a really nice to have, and shouldn\u0027t prevent us from merging this change as is and fixing highest priority bug we can have: intermittent data corruption +  corrupted changes hanging forever in merge queue in \"Submitted, Merge pending\" state. Once this is fixed on all stable branches (most important 2.8.x and 2.9), we can consider to implement that nice to have check. TBH, given that we are going to evacuate the database backend and migrate it to Git, i am not convinced it worth doing it at all.\n\nJust checked: on master:\n\n  $ git grep beginTransaction\n\nproduces only 18 matches in source code and i am not sure that we are going to see new location next time. And what kind of breakage you would catch? Something that\u0027s really unlikely to happen without to be discovered during debug/test cycle:\n\n  Change foo \u003d ...;\n  Change bar \u003d ...;\n  try {\n    db.changes().begingTransaction(foo.getId());\n    PatchSet.Id psBarId \u003d \n      ChangeUtil.nextPatchSetId(repo, bar.currentPatchSetId());\n    PatchSet psBar \u003d new PatchSet(psBarId);\n    // popuplate psBar\n    [...]\n    // the next statement would throw GroupEntityMismatch exception:\n    // Transaction was started for group entity 4711 (type\u003d\u0027change\u0027),\n    // but the mutated entity belongs to group entity 4712 (type\u003d\u0027change\u0027)\n    db.patchSets().insert(Collections.singleton(psBarId));\n\nAgain, we could (optinally) do that but only on master and only after we\u0027ve fixed this higest priority bug on stable branches.",
      "parentUuid": "3f2c6c7a_480a1f41",
      "range": {
        "startLine": 42,
        "startChar": 31,
        "endLine": 42,
        "endChar": 37
      },
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44a155b9_600e3255",
        "filename": "src/main/java/com/google/gwtorm/jdbc/JdbcAccess.java",
        "patchSetId": 3
      },
      "lineNbr": 42,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-06-24T16:04:20Z",
      "side": 1,
      "message": "Iae76682a is a real-world example of a bugfix we had to make that was only discovered once it hit production.\n\nAs I said elsewhere I\u0027m fine with this for now. These issues are easy to track down in our logs, but rolling back releases and whatnot is always a bit of a pain. So I\u0027m hoping I don\u0027t regret my decision :)",
      "parentUuid": "0424bda2_b623e8c6",
      "range": {
        "startLine": 42,
        "startChar": 31,
        "endLine": 42,
        "endChar": 37
      },
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0424bda2_762670df",
        "filename": "src/main/java/com/google/gwtorm/jdbc/JdbcAccess.java",
        "patchSetId": 3
      },
      "lineNbr": 43,
      "author": {
        "id": 1016473
      },
      "writtenOn": "2014-06-17T19:12:36Z",
      "side": 1,
      "message": "Why we not put beginTransaction(K key) in Schema.\nAnd pass (K key) here?\n\nGood to be clear we do not support/or support nested transaction. (Save point in Oracle)\n\n// call 1 \nent.beginTransaction(K key)\n\n// call 2 \nent.beginTransaction(K key)\n\n// End tr for call 2\nschema.commt()\n\n// End tr for call 1\nschema.commt()\n\nCall 2 is ignored, or is not supported.",
      "range": {
        "startLine": 43,
        "startChar": 0,
        "endLine": 43,
        "endChar": 4
      },
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0424bda2_9607cc36",
        "filename": "src/main/java/com/google/gwtorm/jdbc/JdbcSchema.java",
        "patchSetId": 3
      },
      "lineNbr": 52,
      "author": {
        "id": 1016473
      },
      "writtenOn": "2014-06-17T19:12:36Z",
      "side": 1,
      "message": "Begin transaction is in Access interface (Let\u0027t say table/entity level)\nAnd Commit/Roolback on Schema level.\n\nThis do not work with GAE transaction model where we have transaction at the entity group.\n\nFor JDBC is fine. (One connection, one database)",
      "range": {
        "startLine": 52,
        "startChar": 2,
        "endLine": 52,
        "endChar": 8
      },
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "44a155b9_400b2e43",
        "filename": "src/test/java/com/google/gwtorm/schema/sql/DialectH2Test.java",
        "patchSetId": 3
      },
      "lineNbr": 69,
      "author": {
        "id": 1010008
      },
      "writtenOn": "2014-06-24T16:04:20Z",
      "side": 1,
      "message": "I imagine there is some reason for this due to schema upgrades but it\u0027s non-obvious why you would want to drop tables in setUp. Add a short comment?",
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a4485179_c3e4564a",
        "filename": "src/test/java/com/google/gwtorm/schema/sql/DialectOracleSQLTest.java",
        "patchSetId": 3
      },
      "lineNbr": 226,
      "author": {
        "id": 1016473
      },
      "writtenOn": "2014-06-17T19:12:36Z",
      "side": 1,
      "message": "Where we have full valid code like:\n\n  beginTransaction();\n  try {\n    insertPatchSetAncestors();\n    insertPatchSets();\n    updateChange();\n    commit();\n  } catch (OrmException e) {\n    rollback();\n  }\n\nFor me valid place for rollback(); is in  finally block.\nSimple NPE generate invalid state here.",
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0424bda2_b6f1a806",
        "filename": "src/test/java/com/google/gwtorm/schema/sql/DialectOracleSQLTest.java",
        "patchSetId": 3
      },
      "lineNbr": 248,
      "author": {
        "id": 1010015
      },
      "writtenOn": "2014-06-17T08:44:02Z",
      "side": 1,
      "message": "should we also check before commit()?",
      "revId": "4e7dc21ee5e634f112bd86f173bcea6e3a9e7737",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": false
    }
  ]
}